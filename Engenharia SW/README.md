# Repositório Bertoti - 11/08

## Trecho 1:

We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

### Comentário:

Para um engenheiro de software, eles tem mais conhecimento acerca do tempo, e, consequentemente, sabe como administrar-lo melhor.
Em relação a escala, é importante também eles terem uma noção sobre o tamanho do projeto, assim, podem fazer o projeto com o máximo de eficiência em um tempo determinado.
Além disso, eles são encorajados a fazer decisões mais complexas, que trará resultados de alto risco, baseados em escalas e tempo desconhecido.

## Trecho 2:

Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

### Comentário:

# 14/08

Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

## Comentário:

## Exemplos de trade-offs:

Escolha de uso de uma IDE, escolha de linguagens e resolução de um problema com duas soluções.

3) Escolha outro exemplo e faça essa mesma atividade:

Linux e Windows.

Comodidade x Versatilidade
Simplicidade x Complexidade

Primeiramente o costume, as pessoas estão mais acostumadas a conviver com o Windows instalado no PC do que o Linux, mesmo o próprio sendo "open source" no qual dá pra mexer em praticamente tudo.
Além da interface gráfica do Windows ser bem mais convidativa, sendo mais fácil de entender-la.

# 18/08

### Qual o requisito não funcional? 
Usabilidade.

Qual a importância?
Experiência do usuário (UX).

Como "obter" este requisito não funcional para o meu software?
Aplicando estas 10 heuristicas.

Encontre 1 erro e 1 acerto de cada heuristica e coloque no seu README.md no GitHub.

#1: Visibility of system status:
Windows no status "Iniciando...", você não sabe o que realmente está sendo iniciado.
WhatsApp você sabe quando a pessoa está digitando, on-line e/ou gravando áudio.

#2: Match between system and the real world:
Erro 404
"Ops! Aconteceu um erro!"

#3: User control and freedom:
Windows quando o sistema trava, as únicas opções seriam tirar o computador da tomada ou desligar e religar manualmente.
Android tem uma saída de emergência que seria a de reinicio rápido do celular, sendo útil em momentos onde todo o sistema trava e não dá para mexer em nada.

#4: Consistency and standards:
O site da Kabum não tem o icone de "lupa" que significa "pesquisar", que no consenso atual, você olha pra ela e já associa com pesquisa. No site tem um "Busque Aqui" gigante.

#5: Error prevention

Formatação de informações, como CPF ou número de telefone. Isso serve tanto pra exemplo bom quanto para exemplos ruins.

#6: Recognition rather than recall


#7: Flexibility and efficiency of use

#8: Aesthetic and minimalist design

#9: Help users recognize, diagnose, and recover from errors

#10: Help and documentation

